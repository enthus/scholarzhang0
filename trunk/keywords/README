
基本事实：

    * 单向发送询问，对方会收到应该收到的所有型的RST，但是询问发起方不会收到type2的。只要对方有回复带ACK的包，发起方就可以收到type2的RST了。由于单向发送询问已经触发了type2，所以再发SYN就可以得到type2的继发SYN/ACK。
    * 302 重定向无论是单向还是双向都无法触发type2。
    * type2和type1是无关的，甚至type1和type2可以不同时坏掉。
    * 对 wikipedia的定点封锁条件是da或者sa == 208.80.152.2，对检测wikipedia的深度关键词是方便的。


URL 关键词检测

程序运行需要*nix下的root权限（setcap?）或者windows下的系统管理员权限。需要在配置文件或者参数中指定一些目标IP、目标端口对 (da, dp)，以及要使用的网络设备（eth0，ppp0等），也可以指定需要设置的源IP地址sa。程序在非公网环境或者设置了苛刻防火墙规则的网络中一般无 法正常运行，这是因为程序会发起大量并发连接有可能导致局域网通信瘫痪，并且单向不建立连接地发送一系列TCP包可能会被防火墙拦截。

单次询问流程：

    * 每次询问挑选1个可用(da, dp)发送s;a;pa;s，每个包重复发送x遍（默认为3）；每两个包间隔t ms发送（默认为30）。如果无sa或者无r，也有可能是gfw对这个(da, dp)无视了，这时应该再发送www.youtube.com来尝试触发。如果触发，说明原本确实没有关键字；否则说明这个(da, dp)在实验中不能采用了。
          o 每次询问报废n个(da, dp)（对于每种type）。
          o 由于GFW的 type1和type2坏掉的点无关，所以认为无法同时得到type1和type2的结果。
          o 需要注意的是：即便是在测试type1，也不能省去最后发的s，除非type1测试后不再测试type2。理由见下面的“(da, dp)列表的维护”。


检测模式：

    * 多目标IP工作模式
          o 情况1、假定只有一个关键词。
                + 假设 str长len，发起len个询问，第i个询问检测str去掉第i个字符形成的字符串。如果有阻断，说明这个字母可以去掉，否则说明这个字母不能去掉。询问完全是并行的。拿到所有结果之后可以立刻求出关键字。
                + 理想情况下只要1单位时间。
          o 情况2、假定所有关键词都是普通关键词，求出所有最小关键词。
                + 这种情况下可以进一步假定关键词是互不包含的子串，所以关键词可以定义前后关系。假设str长度为len，发起len个询问，第i个询问去掉前len + 1 - i个字符。求出最大的j使得在去掉前j个字符的情况下仍然有关键词。现在只需要求出从第j+1个字符开始的关键字，发起len - j个询问，第i个询问去掉后len - j + 1 - i个字符。现在求出最大的k使得去掉后k个字符仍然有关键字就完了。最后一个关键字就是str[j + 1..len - k]，共花去2单位时间、询问。接下来处理str[1..len - k - 1] with hint: "开头位置 <= j"，仍然是倒着测，有助于及时break。
                + 理想情况下时间等于关键词数目。
                + 为了减少报废数目（短时间报废过多会被迫等待继发封锁结束），可以使用“二级索引”的办法：分sqrt(len)块，然后再精确到块内的位置。这样只是时间*2。
          o 情况3、&&型关键词、可能有多个，求出所有关键词。
                + 即使是求出其中的某一个关键字都是必须串行的，要花len 的时间，难以忍受。但是实践中，.google.com && ** 和 search && ** 和 q=** 有可能同时是关键字，而询问作为www.google.com/search?q=**出现。由于此问题可由3-SAT规约到，故可认为不可做，所以可从其它方面考虑：
                      # 1. 根据经验假设只会出现2个&&，但其实GFW有能力实现带任意次&&的匹配。
                      # 2. 令s为{1..len}的一个随机置换，顺次考察s[i]，如果去掉后仍然触发就去掉，不再触发就保留。最后可以得到一个关键字。k（默认30）路并行应该就差不多了。尽管到达每个关键字的概率不均匀，但是实践效果应该可以接受。
    * 固定IP工作模式
          o 有定点封锁的URL关键字么？好吧这只是一个运行模式而已。流程跟上面相同。
    * 固定IP、Port工作模式（实际中无此需要，不实现）
          o 情况1、求出所有简单关键词。
                + 假设一次询问1.5sec，那么90秒能询问60次。所以解一下方程 1 - x^60 = x 。第一轮询问确定开头的下标，第二轮询问确定结尾下标。第一轮询问中按照x:1-x的比例二分。这求出了第一个关键词，然后继续求。
                + 每个关键词的时间期望为2 log_x(len)。


具体实现：（配合代码阅读，以下所称队列均为优先队列、type表示GFW的回应type）

    * 多线程。
          o 其中一个负责初始化以及向连接队列中增加条目；
          o 一个负责从连接队列中取出一个连接条目并发送包：更新当前连接状态或者删除当前连接、维护连接hash表；初始化当前连接时会请求一个(da, dp)对并从空闲(da, dp)队列中删除、删除当前连接时会相应地更改可用(da, dp)列表和空闲(da, dp)队列；
          o 最后一个线程负责接收包，根据包在hash表中反查对应的连接，根据返回判断是否匹配GFW以及匹配的GFW类型；
                + 如果有GFW 相应type的返回就可以调用检测完毕的callback函数了。
                + 但是如果只是这个type有返回，还是应该等timeout之后看另一个type是否有返回。理由见下面的“(da, dp)列表的维护”。
                + 如果两个type都有返回，就可以结束当前连接了，所以需要修改连接队列中对应条目的处理时间到当前时间以便马上处理。
                + 由于丢包可能造成没有看到GFW的返回造成上次对 (da, dp)的处置失误。如果允许这种误差，就必须容忍(da, dp)被错删、被错误设置了恢复时间，还应当判断是否处在继发状态。无论是实现的复杂性还是结果的正确性都难以承受。所以假设GFW的包总能收到，如果收到了非预期的GFW包，就报告并忽略。如果网络状况不好就修改参数再做。建议在诊断期间不要让其它程序对在(da, dp)列表中的目标进行连接。
          o 所以需要设置锁的地方有：hash表、连接队列。
    * 从上面的算法可以看出，最大同时连接数分别只有len、sqrt(len)、k，所以设置为10000足够了。
    * 更具体地，对于连接队列，线程 1只增加、线程2只减小、线程3不改变其数量，所以线程1中增加的时候如果遇到队列满只需要while(full);之后再lock掉队列操作就可以了。事实上，由于设置成10000绰绰有余，根本不需要判断队列是否满。线程2中只需要while (empty);之后就可以lock掉队列然后操作连接队列。
    * (da, dp)列表的维护
          o 一方面，type1, type2的(da, dp)列表是不同的（GFW可能会关掉一些节点）；
          o 另一方面，由于可能在测试type2的时候引起type1的封锁、在测试type1的时候引起type2的封锁；
                + 所以接受包的线程在更新
          o type1 和type2不能同时使用一个(da, dp)（尽管我们的算法中不会出现这种情况）。
          o 所以需要在请求任何一种type的(da, dp)时，请求之后应当从另一种type的空闲(da, dp)删除它，使用完毕后应当根据触发的情况判断这个(da, dp)是否还应当保留在每个type的可用列表中，如果需要保留，那么应当在对应的空闲列表中增加正确的时间，因为有可能本来对于另一个type来说它可能在60秒后就可以使用了，那这次使用时有没有触发那个type，需要设置的恢复时间是不同的。
                + 其实对于每个type的可用 (da, dp)，它要么在使用中，要么就在空闲队列中。对每个type维护一个所谓的可用列表是多余的。
                + 用一个全局(da, dp)列表，记录这个元素是否可用于某个type以及在每个type的空闲列表中的位置。
                + 如果某个type的可用(da, dp)损失太多（hard code为所剩小于capacity的一半），就从IP池中补充。
                      # 假设(da, dp)列表中只可用于type1的有a1个，只可用于type2的有a2个，都可用的有a0个。断言任何时候min(a1, a2) + a0 <= capacity, max(a1, a2) <= capacity。初始时a0 <= capacity，a1 = a2 = 0。由于除非进行补充，a_i不增加，断言仍然成立。如果进行了对type_i的补充，则补充过程中只是a0增加，并且补充后a_i + a0 <= capacity，从而仍然被满足。于是a0+a1+a2 <= 2*capacity。并且最坏情况下可能出现a1 = 0, a0 = a2 = capacity的情况。所以全局(da, dp)列表大小以及两个type的空闲队列大小设置为2 * capacity就好了，另外还可以看出a0 <= capacity，于是两个队列的总大小至多只有3 * capacity。